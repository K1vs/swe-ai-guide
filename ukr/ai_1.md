## 1. ШІ - інструмент #2 відразу після розуму розробника

Сучасний ШІ у розробці - це стрибок за межі "кращої IDE": він додає швидкість, зводить рутинну працю до нуля і підвищує якість за рахунок вивільнення часу людини, який можна спрямувати на забезпечення якості давно відомими методами, на які ніколи не було часу. Правильно застосований, ШІ не замінює мислення, а підсилює його, перетворюючи ідеї на результат значно швидше і надійніше.

### Чому саме зараз

- **Доступність**: почати користуватися дуже просто, можна поетапно, додаючи нові сценарії використання ШІ у міру потреби та готовності. Починайте зі звичних інструментів, які вже використовуються в розробці, встановлюючи в них ШІ-розширення.
- **Контекст**: моделі вже вміють утримувати достатній контекст для виконання етапу типового декомпозованого завдання у типовому проєкті.
- **Якість**: під наглядом людини, яка здатна керувати декомпозицією задачі, перевіряти та коригувати план робіт, ШІ здатний виконувати завдання з цілком прийнятним рівнем якості.
- **Швидкість**: деякі завдання, особливо прості та типові, ШІ здатний виконувати значно швидше за людину. Крім того, ШІ може швидко виконувати навіть складні, але дуже чітко описані та обмежені завдання, на які людина могла б витратити багато часу. І хоч відсоток таких завдань невеликий, ШІ скорочує час їх виконання на порядок, що робить помітний внесок у загальну швидкість розробки.
- **Інструменти**: сьогодні ШІ - це вже не гола модель, яка здатна лише вести розмову в чаті, а потужний інструмент, який може виконувати багато завдань із мінімальною участю людини. Це практично вирішує проблему минулих років, коли розповісти про контекст задачі для ШІ і перенести результат було довше, ніж самостійно виконати завдання.

## Де та як вже сьогодні можна почати використовувати ШІ в розробці?

Це поверхневий список коротких прикладів, які можна почати використовувати вже сьогодні. Не варто відноситись до цього як до вичерпного списку, але варто почати з цього. Як саме це робити також описано дуже стисло, але це вже буде гарним початком.

### 1) Тести: модульні та інтеграційні

- **Опишіть API**: одразу опишіть API модуля, який тестуєте. Додайте в контекст файл чи каталог із ним.
- **Працюйте покроково**: не давайте агентові занадто загальний запит на кшталт "зроби тести для всіх методів". Описуйте кожен тест окремо: назва, передумови, кроки, очікування, що потрібно мокати. Це трохи довше, але ви отримуєте саме ті тести, які вам потрібні, і самі зайвий раз подумаєте над валідністю вимоги.
- **Розвивайте поступово**: "щасливий шлях" → негативні сценарії → крайові випадки. Чим більше є тестів для модуля, тим краще ШІ генерує наступні, складніші тести.

Результат: гарне покриття тестами за малі гроші, яке можна розвивати поступово; ціна кожного нового тесту все менша і менша.

### 2) XML-коментарі, логи, трейси: автокомпліт "з коробки"

- **Автоматизація вбудованої документації**: якщо тіло методу чисте і без "кашемалаші", ШІ впевнено добудовує XML-коментарі, підписи до параметрів та повернень.
- **Логування і трасування**: надайте шаблон, що і як потрібно логувати, - і агент швидко виконає цю задачу. А для нового коду покладайтесь на автокомпліт, який за секунду додасть потрібний лог за контекстом.

Результат: документація і діагностика не гальмують, не завантажують розробника, але різко підвищують спостережуваність та зрозумілість поведінки програми.

### 3) Імплементація бізнес-логіки за контрактом

- **Бізнес-логіка**: скопіюйте у контекст потрібний фрагмент вимог або посилайтесь на номер задачі у Jira (за наявності MCP).
- **Контракт**: визначте контракт, зробіть пустий метод із сигнатурою, який потрібно реалізувати.
- **Тести**: напишіть тести для контракту під вимоги; якщо у тікеті є AC - то ШІ впорається з мінімальними втручаннями.
- **Реалізація**: попросіть ШІ надати реалізацію - він напише код, який відповідає вимогам, контракту і тестам.
- **Ітеративність**: за потреби - вносьте коригування в код, вручну чи агентом, до досягнення коректності та бажаної якості.

Результат: швидка та якісна реалізація бізнес-логіки.

### 4) Робота за аналогією і розповсюдження рішень

- **Створюємо приклад**: вручну чи асистовано створюємо приклад, який потрібно розповсюдити.
- **Додаємо в контекст**: додайте в контекст приклад, який потрібно розповсюдити. Додатково опишіть, на що в цьому прикладі варто звернути увагу.
- **Розповсюджуємо**: вкажіть, де потрібно розповсюдити приклад, і ШІ зробить це за вас.

Результат: масштабування кращих практик без ручної рутини й стандартизація стилю та практик.

### 5) Тестові HTTP‑запити та SQL‑скрипти

- **HTTP**: дивлячись на код, особливо якщо він має гарну документацію публічних контрактів, ШІ здатний створити потрібний тестовий запит для VS Code REST Client за вашим побажанням.
- **SQL**: використовуючи розширення для роботи з БД (наприклад, PostgreSQL для VS Code), ШІ здатний створити потрібний скрипт для створення тестових даних чи зібрати дані з БД і зробити по них потрібний аналіз. Для своєї роботи ШІ може спиратися на схему БД, на приклади даних, що в ній є, на те, як ваш код з нею працює, тому навіть базовий опис задачі дає хороший результат. Головне - ніколи не надавати доступ на запис до Production БД.
- **HTTP + SQL**: разом це дозволяє ШІ виконати потрібну вам перевірку за текстовим описом. Якщо сценарій перевірки вдалий - можна зберегти його як інтеграційний тест.

Результат: пришвидшення тестування та діагностики проблем.

## Важливість ШІ в розробці

Сьогодні почати використовувати ШІ в розробці є важливішим, ніж десяток років тому перейти на IDE з блокноту.

Перехід "блокнот → IDE" дав автодоповнення, рефакторинги, дебаг. Додавання ШІ‑агента дає:

- **Створення артефактів**: тести, моки, вбудована документація, телеметрія, реалізації методів, мапінги, валідації - не лише "допомагає писати", а "пише сам" за вашою постановкою задачі.
- **Структуровані трансформації**: складний рефакторинг за прикладом чи за описом того, що потрібно зробити у великому об’ємі коду.
- **Аналіз поведінки коду**: відповіді на питання про те, як код працює, які можливі проблеми, які варіанти вирішення; пояснення причин уже виявленої проблеми.

Це відчутно більший крок, ніж просто "кращий інструмент редагування" - це додавання другого виконавця у вашу команду. Зараз використання ШІ в розробці важливіше, ніж використання IDE протягом останніх 15 років.

### Не тільки швидкість: якість і надійність

- **Більше часу на дизайн**: ШІ знімає рутину, вивільняючи години на моделювання домену, узгодження контрактів і спрощення архітектури.
- **Великі рефакторинги**: швидкі, багатоетапні зміни можна зробити за малий час, а краще покриття тестами (завдяки їх малій ціні) підвищує безпечність рефакторингу.
- **Менше "магії"**: там, де колись були "магічні" фреймворки заради зменшення бойлерплейту, тепер можна писати явний, прозорий код - бойлерплейт згенерує агент. Ясність > магія.

### Синергія з DDD

- **Однозначний контекст**: bounded context, ubiquitous language, агрегати, інваріанти - це саме те, що потрібно LLM. Чіткі назви і кордони мінімізують неоднозначність запитів.
- **Перетворення дизайну в код**: витрачений на дизайн час повернеться відразу, оскільки ШІ зможе працювати швидше й автономніше, маючи чіткий технічний дизайн.
- **Еволюція без руйнування мови**: при змінах у бізнесі агент дозволяє швидко вносити правки, зберігаючи єдність ubiquitous language у реальності та коді.

Підсумок: DDD зменшує складність і дає ШІ якісний, обмежений контекст; ШІ зменшує вартість реалізації DDD і усуває зростання Time to Market.

### Синергія з TDD

- **Здешевлення тестів**: написання тестів - основний "біль" TDD. ШІ радикально знижує ціну створення і підтримки тестів.
- **Тести як специфікація для ЛЛМ**: кожен тест - точно сформульоване очікування. Агент "розуміє", що від нього хочуть, і має явний критерій успіху.

Разом: TDD спрощує розуміння вимог для ШІ, а ШІ прибирає бар’єр вартості тестів.

### Антипатерни, яких варто уникати

- Перевантажені запити "зроби все одразу". Краще - дрібні, послідовні, з чіткими артефактами на кожному кроці.
- Невизначені назви та відсутність контрактів. Вводьте глосарій і фіксуйте інтерфейси до генерації коду.
- Використання LLM для складних нетипових завдань з нечіткими вимогами - буде отримано незрозумілий результат з витратами часу та токенів.

## На завершення

Найважливіша синергія - між людським мозком і ШІ. LLM блискавично генерує багато простих, тривіальних речей і впевнено розв’язує складні, але типові й детерміновані задачі. Людина ж залишається неперевершеною там, де є невизначеність: формує гіпотези, обирає компроміси, бачить сенси, накопичує досвід і вміє абстрагувати. Разом це дозволяє рухатися швидше й надійніше: машина робить те, що можна описати однозначно, а людина спрямовує, визначає і вдосконалює сам опис. ШІ - інструмент #2, але саме тому він перетворює сильну голову розробника на команду, здатну створювати якісний продукт помітно швидше.


## Рекомендовані посилання

- Vaswani et al., "Attention Is All You Need" (2017): [arxiv.org](https://arxiv.org/abs/1706.03762)
- Kaplan et al., "Scaling Laws for Neural Language Models" (2020): [arxiv.org](https://arxiv.org/abs/2001.08361)
- Wei et al., "Chain-of-Thought Prompting Elicits Reasoning in Large Language Models" (2022): [arxiv.org](https://arxiv.org/abs/2201.11903)
- Wang et al., "Self-Consistency Improves Chain of Thought Reasoning in Language Models" (2022): [arxiv.org](https://arxiv.org/abs/2203.11171)
- Schick et al., "Toolformer: Language Models Can Teach Themselves to Use Tools" (2023): [arxiv.org](https://arxiv.org/abs/2302.04761)
- GitHub Blog - "Research: quantifying GitHub Copilot's impact on developer productivity" (2022): [github.blog](https://github.blog/2022-09-07-research-quantifying-github-copilot-s-impact-on-developer-productivity/)
- Microsoft Learn - "Develop with GitHub Copilot" (навчальний шлях): [learn.microsoft.com](https://learn.microsoft.com/en-us/training/paths/ai-developer-github-copilot/)
- Вон Вернон - "Implementing Domain-Driven Design" (Addison-Wesley): [informit.com](https://www.informit.com/store/implementing-domain-driven-design-9780321834577)
- Вон Вернон - "Domain-Driven Design Distilled" (Addison-Wesley): [informit.com](https://www.informit.com/store/domain-driven-design-distilled-9780134434421)
- Кент Бек - "Test-Driven Development: By Example": [informit.com](https://www.informit.com/store/test-driven-development-by-example-9780321146533)
- Мартін Фаулер - "Refactoring: Improving the Design of Existing Code": [martinfowler.com](https://martinfowler.com/books/refactoring.html)
