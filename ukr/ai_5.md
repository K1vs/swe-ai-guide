### 5. LLM-агенти для розробки ПЗ: практична автономність, а не магія

LLM-агент у розробці ПЗ - це інструмент поверх великої мовної моделі. Він читає контекст репозиторію, планує дрібні кроки та виконує дії (редагує файли, запускає команди, пише тести) за запитом інженера. 

На відміну від простого чату, агент працює по процесу: пропонує зміни, показує дифи, вміє повторювати ітерації та підпорядковується критеріям приймання.

#### Основні характеристики агента:
- Контекстність: читає кілька файлів/модулів, враховує структуру проєкту, залежності, інструкції в README/Makefile/CI.
- Планування малих кроків: декомпонує запит у серію дрібних правок/запусків, підтримує історію спроб.
- Інструментальність: вміє викликати компілятор, тести, лінтери, пакетні менеджери, скрипти.
- Прозорість: показує дифи/плани перед застосуванням; можна частково приймати/відхиляти.
- Відтворюваність: зберігає проміжні артефакти (логи, помилки), може сформувати PR.
- Контроль користувача: усі суттєві дії - лише після підтвердження; є механізми "rollback".

#### Чесно про "повну автономність". 
Сьогодні повністю автономні агенти у складній розробці (багатомодульні системи, нефункціональні вимоги, інтеграції, безпека) - недосяжні. Більшість "end‑to‑end" демонстрацій працюють для вузьких, контрольованих сценаріїв. Згадані у медіа "автономні розробники" на кшталт Devin активно використовують маркетингові формулювання; у реальних умовах їх якість і стабільність різко падають поза тривіальними задачами. На практиці потрібні перевірки, рецензії, запуск тестів/CI та ручний нагляд.

Тому фокус - агенти обмеженої автономності, які виконують роботу синхронно і "поруч" з інженером.

#### Як виглядає типовий воркфлоу в агентному режимі (Cursor / Copilot):
1) Постановка задачі: вибираєте код та описуєте бажані зміни природною мовою (наприклад, "мігруй з v4 на v5 бібліотеки X; онови імпорти й тести").
2) Побудова плану і вибір файлів: агент збирає контекст (імпорти, конфіг, залежності), пропонує план змін.
3) Пропозиція дифів: показує серію редагувань по файлах; ви приймаєте/редагуєте частинами.
4) Локальні перевірки: запуск лінтерів/тестів/білду; збір логів і уточнення плану при фейлах.
5) Підсумок: оновлення документації/скриптів за необхідності; формування коміту або чернетки PR.

#### Базовий огляд популярних агентів

Cursor
- Плюси:
  - Краще агентне ядро на сьогодні: стабільні багатофайлові дифи, ланцюжок "план → правки → перевірки"; з’явився раніше - більше відшліфованих сценаріїв.
  - Швидке автодоповнення з якісним утриманням контексту активної роботи розробника.
  - Більший вибір моделей (наприклад, OpenAI/Anthropic/Google/XAI) - можна підбирати під задачу, бюджет і швидкодію.
  - Придатний саме як агент: синхронні сесії, запуск команд, ітерації за помилками.
- Мінуси:
  - Окрема IDE (форк VS Code): не всі розширення з VS Code Marketplace доступні через ліцензійні обмеження; альтернативи часто слабші - перевіряйте критично важливі плагіни.
  - Фактор звичок: перехід на іншу IDE може бути болючим для команди (шорткати, конфіги, екосистема).

GitHub Copilot
- Плюси:
  - Практично "рідний" для VS Code; мінімальне тертя в існуючих оточеннях.
  - Доступний у Visual Studio з корисними фічами під час дебагу (пояснення проблем, пропозиції виправлень із використанням зібраних значень змінних).
  - Доступний у Xcode; також працює в JetBrains/Neovim - покриває більшість популярних IDE.
  - Сильний у інлайн‑пропозиціях; зручний для дрібних локальних правок.
- Мінуси:
  - Як агент для багатокрокових/багатофайлових змін поступається Cursor; менше інструментальних сценаріїв у межах IDE.
  - Менше контролю над вибором моделей; складніше оптимізувати під специфічні завдання/вартість.
  - Якість автодоповнення сильніше залежить від активного файлу й інколи виглядає більш загальною.

Консольні агенти (напр., Claude Code)

- Плюси:
  - Агностичність до IDE: повна незалежність від середовища розробки, просто у улюбленій IDE відкриваєте термінал і працюєте з агентом.
  - Виконання на віддалених серверах: CLI/API дозволяє запускати завдання неінтерактивно, зберігати артефакти (логи, звіти), виводити дифи/патчі у файли та повертати коди виходу. Це зручно для вбудовування у GitHub Actions/GitLab CI для масового lint/fix, генерації тестів/доків, audit з фейлом пайплайну при порушеннях.
- Мінуси:
  - Відсутня інтеграція з IDE. Взаємодія завжди через CLI, що не для усіх задач оптимально.
  - Потрібно альтернативне джерело Tab completion, яке не завжди є.

#### Зовсім не автономні сценарії - автодоповнення/інлайн‑чат у IDE - інколи кращі за агентний режим:
- Маленькі локальні зміни, "гаряча" петля редагування, коли витрати на план/дифи перевищують користь.
- Високі вимоги до стилю/безпеки: ви хочете повного контролю кожного рядка.
- Навчання новому API: підказки/сніпети допомагають швидше зв’язати еталонний код без зайвих трансформацій.

#### Більш автономні сценарії: асинхронні агенти
- У Cursor та Claude Code є асинхронний режим: довгі задачі (масові рефакторинги, генерація тестів/доків, метрики, інвентаризація залежностей) запускаються у фоні; після завершення отримуєте звіт і дифи для рев’ю. Це зручно, коли робота триває десятки хвилин і не має блокувати основне редагування.
- Є ще "базово асинхронні" продукти на кшталт Google Jules, орієнтовані на більш тривалі та багатокрокові завдання з мінімальним втручанням користувача. Їхні сильні сторони - планування, спостереження за середовищем, переробка плану при збоях; але якість і передбачуваність усе ще далекі від рівня, придатного для критичного продакшну без людського контролю. 

Але для специфічних завдань, наприклад, для підйому версій залежностей, з виправленням breaking changes спираючись на release notes, це може бути корисно. Або, наприклад, для заміни одного фрейворку чи бібліотеки на аналогічний. В майбутньому це може стати корисним для більшого кругу задач.

#### Практичні поради вибору режиму:
- Найменша необхідна автономність: беріть той рівень, що закриває задачу з мінімальними накладними витратами.
- Інлайн‑пропозиції - для локальних правок, шаблонів, невеликих функцій.
- Агент у редакторі - для змін у кількох файлах, механічних міграцій, системних рефакторингів.
- Асинхронний агент - для довгих, шумних, ресурсомістких процедур, які можна надійно і однозначно описати одним промтом та легко перевірити за звітом/дифами.
- Завжди вимагайте прозорості: попередній план, дифи по файлах, журнали запусків і повторюваність кроків.

Нижня межа правди така: агенти вже економлять години на рутині, але без людського інженерного судження - ні кроку. Найкращі результати дає поєднання: чітка постановка задачі, дрібні ітерації, перевірки тестами та уважний код‑рев’ю. Саме так агенти стають мультиплікатором продуктивності, а не джерелом прихованого боргу.



#### Джерела та подальше читання

- Огляд підходів: Lilian Weng - “LLM Powered Autonomous Agents” (`https://lilianweng.github.io/posts/2023-06-23-agent/`)
- ReAct (Yao et al., 2022): “ReAct: Synergizing Reasoning and Acting in Language Models” (`https://arxiv.org/abs/2210.03629`)
- Toolformer (Schick et al., 2023): “Language Models Can Teach Themselves to Use Tools” (`https://arxiv.org/abs/2302.04761`)
- Reflexion (Shinn et al., 2023): “Language Agents with Verbal Reinforcement Learning” (`https://arxiv.org/abs/2303.11366`)
- LangGraph (LangChain, 2024): графові агенти та оркестрація (`https://langchain-ai.github.io/langgraph/`)
- LangChain - агенти: концепції та приклади (`https://python.langchain.com/docs/concepts/agents/`)
- LlamaIndex - агенти: огляд і керівництва (`https://docs.llamaindex.ai/en/stable/understanding/agent/`)
- Microsoft AutoGen: мультиагентні сценарії та кооперація (`https://microsoft.github.io/autogen/`)
- Anthropic Claude - Tool Use / Function Calling (`https://docs.anthropic.com/claude/docs/tool-use`)
- OpenAI - Assistants API та інструменти (`https://platform.openai.com/docs/assistants/overview`)
- AgentBench: порівняльна оцінка агентів (`https://github.com/THUDM/AgentBench`)
- SWE-bench: бенчмарк для агентів‑розробників (`https://github.com/princeton-nlp/SWE-bench`)
- Документація Cursor (`https://docs.cursor.com`)
- Документація GitHub Copilot (`https://docs.github.com/en/copilot`)